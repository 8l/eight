; hi! If you're reading this to learn about eight, I suggest skipping the 
; following 4 functions, until you're more comfortable with the language.
; If you feal comfortable with the Eight function 'leak', and the behavior of
; Eight's semiotic programming features, then by all means, dive in. Otherwise,
; skip to 'do', and work from there. Good luck!
;
; --s
;
(base-signal-handler '((q) (print q)))

(set! unlambda '((list)
		 (oif list (oif (is (car list) '...) 
		    	        (unlambda (cdr list))
   			        (cons (oif (atom-p (car list)) 
				           (car list) 
				           (oif (is (car (car list)) 'quote)
					       (car (cdr (car list)))
					       (car (car list))))
				      (unlambda (cdr list)))) ())))
; ought to make this tail recursive

(set! leak-all '((list closure)
		 (oif list (leak-all (cdr list) (leak (car list) closure)) closure)))
 
(set! fn '(('lambda-list ... 'code)
	   (cons lambda-list (leak-all (unlambda lambda-list) code))))


;-----------------------------------------------------------;


(set! do (fn (... 'evals)
             ((fn () *evals))))


(set! def (fn ('name 'lambda-list ... 'code) 
              (set! ,name (fn ,lambda-list *code))))


(def caar (xs) (car (car xs)))
(def cadr (xs) (car (cdr xs)))
(def cddr (xs) (cdr (cdr xs)))

(def no (x) (is x ()))

(def cons-p (x) (no (atom-p x)))

(def copylist (xs)
  (oif (no xs)
      ()
      (cons (car xs) (copylist (cdr xs)))))

(def list (... args) (copylist args))

(def identity (x) x)

(def if (test 'then ... 'elses)
  (oif test
      ,then
      (oif (cdr elses)
           (if *elses)
           ,(car elses))))

(def map1 (f xs)
  (if xs 
      (cons (f (car xs)) 
	    (map1 f (cdr xs)))))

(def pair (xs (f list)) 
     (if (no xs)
          ()
         (no (cdr xs))
          (list (list (car xs)))
         (cons (f (car xs) (cadr xs))
               (pair (cddr xs) f))))

(def and ((arg t) ... 'args)
  (if args 
      (if arg (and *args))
      arg))

(def assoc (key al)
  (if (atom-p al)
       ()
        (and (cons-p (car al)) (is (caar al) key))
       (car al)
        (assoc key (cdr al))))

(def alref (key al) (cadr (assoc key al)))

(def acons (key val (al ()))
	(cons (list key val) al))

(def with ('parms ... 'body)
  ((fn (map1 car (pair parms))
       *body)
   *(map1 cdr (pair parms))))

(def let ('var val ... 'body)
	(with (,var val) *body))

(def withs ('parms ... 'body)
  (if parms
      (let ,(car parms) ,(cadr parms)
	   (withs ,(cddr parms)  *body))
      (do *body)))

(def join (... args)
  (if args
      (let a (car args) 
        (if a
	    (cons (car a) (apply join (cdr a) (cdr args)))
	    (apply join (cdr args))))))


(def nest (xs (core ()))
  (if (cdr xs)
      (cons (car xs) (list (nest (cdr xs) core)))
      (cons (car xs) core)))

; You could have the innermost fn take any number of args,
; but you'd have to evaluate that arg once to pick out the
; lambda list, and it's plausible that that would poke a 
; hole in the abstraction.
(def compose (... 'args)
  (fn (arg) ,(nest args '(arg))))

(def complement (f)
    (fn (... args) (no (f *args))))

(def isnt (x y) (no (is x y)))

; or in arc is 32 tree-nodes; mine is 19.
(def or (arg ... 'args)
  (if args
      (if arg arg (or *args))
      arg))

(def alist (x) (or (no x) (consp x)))

; I am confused why he used a rest argument for this.
(def in (x ... choices)
  (or *(map1 (fn (y) (is y x)) choices)))

(def iso (x y)
  (or (is x y)
      (and (consp x) (consp y)
	   (iso (car x) (car y))
	   (iso (cdr x) (cdr y)))))

; I am not sure these are necessary. We'll see. I may delete them.
(def when (test ... 'body)
  (if test (do *body)))

(def unless (test ... 'body)
  (if (no test) (do *body)))

(def while ('test ... 'body)
  (when ,test *body (while ,test *body)))

(def reclist (f xs)
  (and xs (or (f xs) (reclist f (cdr xs)))))

(def testify (x)
  (if (atomp x) 
      (fn (a) (is a x))
      x)) ; graham's testify is brilliant, but I don't have a sure way
; to id functions as functions.


; Thses could be optimized, but the idiomatic versions are so 
; dogamn pretty.
(def some (test seq)
  (reclist (compose (testify test) car) seq)) ; can some become find?

(def all (test seq)
  (and *(map1 (testify test) seq)))

; mem goes here, but I have no idea why I'd want it.

(def find (test seq)
  (reclist (fn (x) (if (test (car x)) (car x))) seq))

(def map (f seq ... 'seqs)
  (if (no seqs)
      (list (map1 f seq))
      (cons (map1 f seq)
	    (map f *seqs))))


; I don't like the fact that I must quote yss here; I think I may
; have made a bad decision about the asterix operator.
(def append (xs ys ... 'yss)
  (if xs
      (cons (car xs) (append (cdr xs) ys *yss))
      yss
      (append ys *yss)
      ys))

;nother iffy quote; not sure this fn is needed at all; really doubting *

(def mappend (f ... args)
  (append @(map f @args)))

(def firstn (n xs)
  (if (no n) xs
      (and (> n 0) xs) (cons (car xs) (firstn (minus n 1) (cdr xs)))
      ()))

(def nthcdr (n xs)
  (if (no n) xs
      (> n 0) (nthcdr (- n 1) (cdr xs))
      xs))

(def tuples (xs (n 2))
  (if (no xs)
      ()
      (cons (firstn n xs)
	    (tuples (nthcdr n xs) n))))

(def caris (x val) 
  (and (acons x) (is (car x) val)))

; Atomic operations here, but I don't currently have threading.

(def table () ())

(set! sref assoc)

(set! setter (table))

(def defset ('name 'parms ... 'body)
  (set! setter (acons name (fn ,parms ,body) setter)))

(defset car (x val)
  (scar x val))

(defset cdr (x val)
  (scdr x val))


		       
	

(def aif (it 'then ... 'elses)
  (if it ,(leak 'it then)
          (cdr elses)
           (aif *elses)
         ,(car elses)))
