                                 .ooooo.          
                                d88'   `8. 
                                Y88..  .8' 
                                 `88888b.  
                                .8'  ``88b 
                                `8.   .88P 
                                 `boood8'  



Document last modified: 7/12/2010                                      
Eight 2010, a lisp by Sam Bleckley

Contact me!
Sam Bleckley
http://diiq.org/
stm31415@gmail.com
405-550-3487


Eight is a language intended to be beautiful and emotional and
extraordinarily powerful. Speed and ease of learning are not 
priorities. Programmers want to be magic ninjas. Eight is designed
to do magic ninja things.


    Gnawing on bones
    My tongue is sore from trying to get the marrow out
    I refuse to ignore the meat any longer


Eight is intended to make metaprogramming easier. It is based on
lisp, but with significant changes under the hood. Because it's currently
pre-alpha, please expect nothing and be surprised when you get
something.

To install Eight, clone the repository, open a terminal and run:

make
./eight



To see example functions in Eight, look through floor.8. I'd skip the
first 6 or 7 functions --- they're tricksy --- but the rest of the
file is good fodder for learning. You can also use the help function
in the interpreter; for instance:

-> (help rest)

Will print a help statement about the 'rest' function. If you're lucky.




WARNING: If you're just interested in playing around with Eight, I'd
recommend NOT reading the rest of this document. If you want to hack
at the source, I'd HIGHLY recommend reading the rest of this document.



--------------------------- HOW IT WORKS --------------------------


Eight is based on a re-imagining of the ancient lisp functions 
cons, car, cdr, and quote.

In order to understand these changes, it's important to understand
what a functional closure is. Check out
http://en.wikipedia.org/wiki/Closure_(computer_science) and SICP.

Eight stretches the idea of closures a little bit --- instead of being
around functions, eight can close over any structure of symbols.

Instead of returning its argument unevaluated (like it does in
McCarthy's lisp), quote in Eight (') returns a closure over its
unevaluated argument. Because this happens invisibly, it is somewhat
hard to demonstrate. Here's a first attempt:

    ->(set! a ((fn (func) (' (func $A $B $C))) list))
    (func $A $B $C)

So, that line makes a function. The function takes another function as
an argument. The anonymous function is called with list as it's
argument. It returns the quoted list (func $A $B $C), and binds the
symbol a to it. Because that list was made with ', it is a closure!

    ->(closing-of a)
    ((func ((... args) (copylist args))))

Calling closing-of returns the closing of an Eight object as an assoc
list (a list of symbol/value pairs). ((... args) (copylist args)) is the
signature of the list function. So that means that func is still bound
to the list function --- but only inside (func $A $B $C). Just
evaluateing func:

    ->func

Will throw an unbound-symbol error. But evaluating a (Eight uses , for
eval):

    -> (, a)
    "ABC"

$A is the character 'A' --- and a list of characters is a string. So
calling (list $A $B $C) returns "ABC"; because func is bound to list,
that's what we get! Hooray!

Once quote is altered in this way, cons, car, and cdr must be changed,
too. For instance:

    ->(closing-of (car a))
    ((func ((... args) (copylist args))))

but 

    ->(closing-of (cdr a))
    ()

Because the car of a is the symbol func, it must retain the
environment it was made in. But the cdr of a is ($A $B $C) --- which
contains no symbols that have been closed-over, and so the closure is
unnecessary.



-------------------------- THE INTERNALS -------------------------

There are 12 files of particular interest:

eight.h is the header file, and contains struct, type, and function
declarations, along with any global variables. 
 
main.c declares the main() function, which initializes the machine and
starts the interpretation of code.

floor.8 contains the Eight source necessary to write a full parser in Eight. 

eight.c contains the giant virtual_machine_step function, that does
the actual work of interpreting Eight code. It also contains all the
associated support functions.

closures.c contains the functions used to create and manipulate the closures,
the objects that eight uses in its computatifications.

basic_commands.c defines and initializes the basic built-in functions
of Eight: car, cons, cdr, read-file, and so on.

memory.c holds the definition of the garbage collector.

parsing.c is a parser. 

strings.c contains the internal functions for string manipulation.

print.c contains the internal output functions.

symbols.c contains the symbol-table and associated
symbol-transformation functions.

test.8 contains a list of functions that verify the proper working of
the Eight machine. It's a good idea to run these after changing the code;
./eight test.8 will diagnose almost every problem I've ever had with Eight.

